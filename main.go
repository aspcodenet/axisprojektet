package main

import (
	"fmt"
	"main/banking"
	"main/dinner"
	"main/printing"
	"net/http"
	"strings"

	"github.com/glebarez/sqlite"
	"github.com/labstack/echo/v4"
	"gorm.io/gorm"
)

type Device struct {
	gorm.Model
	Name          string `gorm:"index"`
	Color         string
	Manufacturer  string
	WeightInGrams int
}

func dbTest() {
	db, _ := gorm.Open(sqlite.Open("./gorm.db"), &gorm.Config{})
	db.AutoMigrate(&Device{})

	device := Device{
		Name:          "Stefan",
		Color:         "da",
		Manufacturer:  "1233",
		WeightInGrams: 121,
	}
	db.Create(&device)
}

func printMenu() {
	fmt.Println("1. Skapa device")
	fmt.Println("2. Lista alla")
	fmt.Println("3. Ändra device")
	fmt.Println("4. Sök")
	fmt.Println("5. Avsluta")
}

// // OOP ???
// // hmmm... lets start with user defined types
// // HockeyPlayer - name, age, jersey
// type HockeyPlayer struct {
// 	Name         string
// 	Age          int
// 	JerseyNumber int
// 	PlayedGames  []Games
// }
// type Games struct {
// }

// func createPlayer() *HockeyPlayer {
// 	var b = HockeyPlayer{
// 		Name:         "tefsan",
// 		Age:          12,
// 		JerseyNumber: 123,
// 	};
// 	var c = HockeyPlayer{
// 		Name:         "tefsan",
// 		Age:          12,
// 		JerseyNumber: 123,
// 	};
// 	return &c;

// 	return &HockeyPlayer{
// 		Name:         "tefsan",
// 		Age:          12,
// 		JerseyNumber: 123,
// 	}
// }
// var p HockeyPlayer
// p.Name = "Stefan"
// p.Age = 123

// var players []HockeyPlayer
// players = append(players, p)

// //var bestPlayer *HockeyPlayer
//
//	p2 := HockeyPlayer{
//		Name:         "tefsan",
//		Age:          12,
//		JerseyNumber: 123,
//	}

// Code generated by go-enum DO NOT EDIT.
// Version: -
// Revision: -
// Build Date: -
// Built By: -

type HockeyPlayer2 struct {
	Name           string
	Age            int
	PlayerPosition int // 0
}

func IsBeautiful(dev *Device) bool {
	if dev.Color == "Green" || dev.Color == "Yellow" {
		return true
	}
	return false
}

func (dev *Device) IsBeautiful() bool {
	if dev.Color == "Green" || dev.Color == "Yellow" {
		return true
	}
	return false
}

func restApi() {
	//Vi ska skapa ett "rest"-API som
	//svarar på HTTP GET /devices och listar alla som JSON
	//Att göra HTTP POST/PUT/DELETE = inte idag men ni kommer
	// se = enkelt
	webServer := echo.New()
	webServer.GET("/devices", getAllDevices)
	webServer.GET("/devices/:id", getSingleDevice)
	go webServer.Start(":8080")
}
func getAllDevices(c echo.Context) error {
	//c.JSON
	return c.String(http.StatusOK, "Alla")
}
func getSingleDevice(c echo.Context) error {
	id := c.Param("id")
	//c.JSON()
	return c.String(http.StatusOK, "Hej hej"+id)
}

func main() {
	restApi()
	//fmt.Println("Hejhej")
	dbTest()
	dinner.Run()

	if newSaldo2, err2 := banking.Withdraw("1111111", 500); err2 == nil {
		fmt.Println("Det fick ju bra, nu gar du", newSaldo2)
	}

	newSaldo, err := banking.Withdraw("1111111", 500)
	if err == nil {
		fmt.Println("Det fick ju bra, nu gar du", newSaldo)
	}

	ps := printing.New(false, false)
	ps.OurPrint("2342343")
	dev := &Device{Name: "wadd", Color: "Green"}

	//if IsBeautiful(dev) {
	if dev.IsBeautiful() {
		fmt.Println("Fin device")
	}

	var aaaa string
	aaaa = "dadadasda"
	if strings.Contains(aaaa, "sada") == true {

	}

	var aa map[string]int
	aa = make(map[string]int)
	aa["555555-1122"] = 12
	aa["720803-1111"] = 13

	fmt.Println(aa["720803-7833"])

	var a int
	a = 1
	if a == 0 || a == 1 ||
		a == 2 {
		fmt.Println("sdadsasda")

	}

	//	stackheap.Demo()
	var devices []Device
	for {
		var val int
		fmt.Printf("Välj:")
		printMenu()
		val = 1 //inputIntData(1, 5, "Ange val:")
		switch val {
		case 5:
			break
		case 1:
			newDevice := createDevice()
			devices = append(devices, *newDevice)
		case 2:
			listAll(&devices)
		case 3:
			changeDevice(&devices)
		case 4:
			search(&devices)
		}
		fmt.Printf("Du valde: %d", val)

	}
}

func createDevice() *Device {
	var device Device

	fmt.Println("*** Ny device ***")
	fmt.Print("Namn:")
	fmt.Scanln(&device.Name)
	fmt.Print("Manufacturer:")
	fmt.Scanln(&device.Manufacturer)
	fmt.Print("Color:")
	fmt.Scanln(&device.Color)
	fmt.Print("Weight:")
	fmt.Scanln(&device.WeightInGrams)

	fmt.Println("*** Device added ***")
	return &device

}

func listAll(devices *[]Device) {
	fmt.Println("*** All our devices ***")
	for _, device := range *devices {
		fmt.Println(device)
	}

}
func changeDevice(devices *[]Device) {
	fmt.Println("*** Select one to modify ***")
	for index, device := range *devices {
		fmt.Printf("%d %s\n", index+1, device.Name)
	}
	sel := 1 //inputIntData(1, len(*devices)+1, "Ange vilken")
	var name, manufacturer, color string
	var weightInGrams int
	fmt.Print("Namn:")
	fmt.Scanln(&name)
	fmt.Print("Manufacturer:")
	fmt.Scanln(&manufacturer)
	fmt.Print("Color:")
	fmt.Scanln(&color)
	fmt.Print("Weight:")
	fmt.Scanln(&weightInGrams)

	(*devices)[sel].Name = name
	(*devices)[sel].Manufacturer = manufacturer
	(*devices)[sel].Color = color
	(*devices)[sel].WeightInGrams = weightInGrams

}
func search(devices *[]Device) {

}

// ag får följande när jag kör go mod init main

// go: modules disabled by GO111MODULE=off; see 'go help modules'
